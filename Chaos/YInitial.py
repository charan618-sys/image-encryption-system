# Importing all the function from Xn module
"""
This module helps in calculating the value of y0 using the first logistic map function Xn
The Y0 value obtained here will be used in the second logistic map Yn
Y0 value is obtained after we sum Y01 and Y02, and mod it with 1


This function takes the list of 10 binary keys and 3 key index values
The 3 given keys are then concatenated to create a 24 bit log binary string B2
This function returns the value of y01
"""
from Chaos.Xn import *

def y01(binary_keys,i=0,j=1,k=2):
    keys = binary_keys
    B2 = keys[i] + keys[j] + keys[k]
    y01 = (int(''.join(B2),2)) / (2**24)
    return y01


# This function takes the list of 10 binary keys, 24 integer values obtained using first logistic map (Xn) and 3 key index values
# The 3 given keys are then concatenated to create a 24 bit log binary string B2
# This function returns the value of y02
def y02(binary_keys,_24_values_of_Pk,i=0,j=1,k=2):
    p24 = _24_values_of_Pk
    keys = binary_keys
    B2 = keys[i] + keys[j] + keys[k]
    y02=0

    for i in range(0,len(p24)):
        y02 = (int(B2[p24[i]]))*(2**i) + y02


    y02 = y02/(2**24)
    return y02

# This function mods the value generated by y01() and y02() function by 1
def y0(y01,y02):
    return (y01+y02)%1


## Test code
#############################################################################
## Using the Key module we generate the 10 8-bit keys and 20 hexadecimal keys from key given by the user
## and use them in y01() and y02() function to generate y0 value which lies between 0 and 1


# binary_keys = to_8bit_keys('ankit12345')
# hex_keys = to_hex_keys('ankit12345')
#
# x0 = x0(x01(binary_keys),x02(hex_keys))
#
# f24 = xn(x0)
#
# p24 = pk(f24)
#
# y0 = y0(y01(binary_keys),y02(binary_keys,p24))
#
# print(y0)
